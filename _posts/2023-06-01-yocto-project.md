# The Yocto Project: It's Linux, stupid!

The spectrum of software complexity and abstraction level nowadays is reeeally wide: It ranges from training super complicated AI stuff on supercomputers through powerful modern laptop PCs down to ticket machines or microwave ovens and all the way down to flipping single bits in a microcontroller. This range of applications often requires completely different techniques and tools and usually different mindsets too. An average person might think 'A computer is a computer, no matter the size! Those geeks just look at their black screens with green letters flashing on them. Using a little PC? You just need to write less code!'. But we are software developers and know better, *right*? There's no single piece of software or framework that's used in that truly diverse spectrum of applications. If you look close enough though, you will see an old friend rising on the hoizon as a truly versatile tool for the future: Linux.

Though some say Moore's law is already dead, this doesn't mean the rapid development of computer technology and with it miniaturization doesn't continue at an extraordinary speed. In recent years, this has lead to unprecedented possibilities in the world of embedded systems. In 2007, the STM32 platform was launched, and in 2012, the Raspberry Pi was born. Since then, credit-card-sized computers have sprang up like mushrooms. The minimum system requirements for running Linux are nowadays satisfied by almost every microchip that cost more than 10 USD.

In this article, we'll be focusing on the lower end of the software complexity spectrum: Embedded systems. 

## 1. Embedded Linux

## 2. Target Devices

## 3. Example: Custom Linux distribution for STM32

Every now and then come over ( anyone?)
